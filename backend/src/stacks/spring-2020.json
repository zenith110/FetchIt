{
 "Problem_Name": "(10 pts) DSN (Stacks)\r",
 "Seen_On": "Spring 2020",
 "Problem_Statement": "Suppose we have implemented a stack using a linked list.\n The structure of each node of the linked list is\nshown below.\n The stack structure contains a pointer to the head of a linked list and an integer, size, to\nindicate how many items are on the stack.\n\ntypedef struct node {\n int num;\n struct node* next;\n} node;\ntypedef struct Stack {\n struct node *top;\n int size;\n} stack;\nWrite a function that will pop off the contents of the input stack and push them onto a newly created stack,\nreturning a pointer to the newly created stack.\n In effect, your function should reverse the order of the items\nin the original stack, placing them in a new stack.\n Assume you have access to all of the usual stack\nfunctions.\n Assume that when you push an item onto the stack, its size automatically gets updated by the\npush function.\n Similarly for pop, size gets updated appropriately when you pop an item from a stack.\n Do\nNOT call pop or peek on an empty stack.\n",
 "Problem_Code": "void push(stack *s, int number); // Pushes number onto stack.\nint pop(stack *s); // Pops value at top of stack, and returns it.\nint peek(stack *s); // Returns value at top of stack.\nint isEmpty(stack *s); // Returns 1 iff the stack is empty.\nstack* reverseStack(stack* s) {\n stack *newS = malloc(sizeof(stack));",
 "Solution": "void push(stack *s, int number); // Pushes number onto stack.\nint pop(stack *s); // Pops value at top of stack, and returns it.\nint peek(stack *s); // Returns value at top of stack.\nint isEmpty(stack *s); // Returns 1 iff the stack is empty.\nstack* reverseStack(stack* s) {\n stack *newS = malloc(sizeof(stack));\n news->size = 0; // 2 pts\n newS->top = NULL; // 2 pts\n while(!isEmpty(s)) // 3 pts\n push(newS, pop(s)); // 3 pts\n return newS;\n}"
}
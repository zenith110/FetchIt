{
 "Problem_Name": "(10 pts) DSN (Linked Lists)",
 "Seen_On": "Spring 2018",
 "Problem_Statement": "Given the linked list structure named node, defined in lines 1 through 4, and the function named\neFunction defined in lines 6 through 14, answer the questions below.\n (a) (1 pt) Is this function recursive? (Circle the correct answer below.\n)\nYES NO\n(b) (2 pts) What does the function eFunction do, in general to the list pointed to by its formal\nparameter, aNode?\n(c) (2 pts) What important task does line 12 perform?",
 "Problem_Code": "1 typedef struct node {\n 2 int data;\n 3 struct node * next;\n 4 } node;\n 5\n 6 node* eFunction(node* aNode){\n 7 if(aNode == NULL) return NULL;\n 8 if(aNode->next == NULL) return aNode;\n 9\n10 node* rest = eFunction(aNode->next);\n11 aNode->next->next = aNode;\n12 aNode->next = NULL;\n13 return rest;\n14 }\r",
 "Solution": "a) YES, b) This function reverses the list originally pointed to by aNode and returns a pointer to the new\nfront of the list. (Grading: 1 pt for reverse, 1 pt for return pointer to reversed list.)\rc) The last node in a linked list must have its next pointer point to NULL. That is how most linked\nlist functions detect the end of the list. Line 12 does this since aNode ends up point to the last\nnode in the list. After the reversal is complete, it's necessary to make sure that the next pointer\nof the last node in the resulting list is pointing to NULL because before line 12 it's not. (It's\npointing to the second node in the original list, which is the last node in the list pointed to by\nrest.)\nGrading: Most of this detail is unnecessary. Full credit for noting that the line sets the last\nnode's next pointer of the resulting list to NULL. Give partial as needed."
}
{
 "Problem_Name": "(10 pts) DSN (Dynamic Memory Management in C)",
 "Seen_On": "Fall 2019",
 "Problem_Statement": "Consider a binary search tree where each node contains some key integer value and data in the form of a\nlinked list of integers.\n The structures are shown below: the tree nodes and list nodes are dynamically\nallocated.\n We are going to eventually upgrade the structure, and when we do so, all of the dynamically\nallocated memory will be deleted (including all of the linked lists).\n Write a function called\ndeleteTreeList that will take in the root of the tree, freeing all the memory space that the tree\npreviously took up.\n Your function should take 1 parameter: a pointer to the root and it should return a\nnull pointer representing the now empty tree.\n",
 "Problem_Code": "typedef struct listNode {\n int value;\n struct listNode * next;\n} listNode;\ntypedef struct treeNode {\n struct treeNode * left;\n struct treeNode * right;\n int value;\n listNode * head;\n} treeNode;\ntreeNode * deleteTreeList (treeNode * root) {}",
 "Solution": "treeNode * deleteTreeList (treeNode * root)\n{\n // Checking the tree is empty 1 pt\n if (root == NULL)\n return NULL; // returning NULL 1 pt\n\n // Loop through (iterative or recursive) list at the node 1 pt\n while (root->head != NULL) {\n listNode * tmp = root->head; // Prevent use after free 1 pt\n root->head = root->head->next;\n free(tmp); // free 1 pt\n }\n // Freeing both children 1 pt each\n root->right = deleteTreeList(root->right);\n root->left = deleteTreeList(root->left);\n // Freeing the tree\u2019s root 1 pt\n free(root); // If the root is free\u2019d last 1 pt\n return NULL; // returning NULL at end 1 pt\n}"
}
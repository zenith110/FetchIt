{
 "Problem_Name": " (10 pts) DSN (Binary Search Trees)",
 "Seen_On": "Fall 2020",
 "Problem_Statement": "Complete the function on the next page so that it takes the root of a binary search tree (root) and an integer\n(key) and, if key is in the tree, returns the smallest integer in the BST that is strictly greater than key.\n If\nkey is not present, or if there is no integer in the tree greater than key, simply return INT_MIN (which is\ndefined in limits.\nh).\n\nYour function must be iterative (not recursive), with a worst-case runtime that does not exceed O(n) (so,\nyou can\u2019t drop the elements into an array and sort them in order to solve the problem).\n\nYou may assume the tree does not contain any duplicate values.\n However, root could be NULL.\n",
 "Problem_Code": "Complete the function on the next page so that it takes the root of a binary search tree (root) and an integer\n(key) and, if key is in the tree, returns the smallest integer in the BST that is strictly greater than key. If\nkey is not present, or if there is no integer in the tree greater than key, simply return INT_MIN (which is\ndefined in limits.h).\nYour function must be iterative (not recursive), with a worst-case runtime that does not exceed O(n) (so,\nyou can\u2019t drop the elements into an array and sort them in order to solve the problem).\nYou may assume the tree does not contain any duplicate values. However, root could be NULL.\n\nIn your solution, you may make as single call to either of the following functions. Assume they\u2019re\nalready written and that they each have a worst-case runtime of O(n):\n\nAn incomplete version of the function and node struct are provided on the following page, along with ten\nblanks for you to fill in to complete the solution. Note that one of these blanks ought to be left blank\nand has been included so that part of the solution isn't given away. Thus, each blank is worth one\npoint, and for at least one of the ten blanks, leaving it blank is the only way to get credit for it.",
 "Solution": "bstNode* insert(bstNode * root, int value){\n if (root == NULL) {\n bstNode* res = malloc(sizeof(bstNode));\n res->data = value; // 1 pt\n res->sum = value; // 1 pt\n res->left = NULL; // 1 pt\n res->right = NULL; // 1 pt\n return res;\n }\n if (value <= root->data)\n root->left = insert(root->left, value) ; // 2 pts\n else\n root->right = insert(root->right, value) ; // 2 pts\n root->sum += value ; // 2 pts\n return root;\n}"
}
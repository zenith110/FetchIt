{
 "Problem_Name": "(10 pts) DSN (Linked Lists)",
 "Seen_On": "Summer 2019",
 "Problem_Statement": "Suppose we have a queue implemented as a doubly linked list using the structures shown below with head\npointing to node at the front of the queue and tail pointing to the node at the end of the queue.\n Write an enqueue function for this queue.\n If the queue is already full, return 0 and take no other action.\n If\nthe queue has not been created yet, return 0 and take no other action.\n If the queue isn't full, enqueue the\ninteger item into the queue, make the necessary adjustments, and return 1.\n Since there is no fixed size,\nthe queue will be considered full if a new node can't be allocated.\n",
 "Problem_Code": "typedef struct node {\n int data;\n struct node *next, *prev;\n} node;\ntypedef struct queue {\nint size;\nnode *head, *tail;\n} queue; int enqueue(queue *thisQ, int item) {\nstruct node *newNode = _ ;\nif(thisQ == NULL) return 0;\nif(newNode == NULL) return 0;\nnewNode->data = _;\nnewNode->next = _;\nthisQ->size = _;\nif(thisQ->head == NULL) {\nnewNode->prev = _;\nthisQ->head = _;\nthisQ->tail = _;\nreturn 1;\n}\n_;\n_;\n _;\n return 1;\n}",
 "Solution": "int enqueue(queue *thisQ, int item) {\nstruct node *newNode = malloc(sizeof(struct node)) ; // 1 pt\nif(thisQ == NULL) return 0;\nif(newNode == NULL) return 0;\nnewNode->data = item; // .5 pts\nnewNode->next = NULL; // .5 pts\nthisQ->size = thisQ->size + 1; // .5 pts\nif(thisQ->head == NULL) {\nnewNode->prev = NULL; // .5 pts\nthisQ->head = newNode; // .5 pts\nthisQ->tail = newNode; // .5 pts\nreturn 1;\n}\nnewNode->prev = thisQ->tail; // 2 pts\n thisQ->tail->next = newNode; // 2 pts\n thisQ->tail = newNode; // 2 pts\n return 1;\n}\nGrading Note: Please count total points and round down to record an integer, so 8.5 gets recorded\nas 8, and 8.0 also gets recorded as 8."
}
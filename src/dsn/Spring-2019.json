{
    "Problem_Name": "DSN (Dynamic Memory Management in C)",
    "Seen_On": "Jan 2019",
    "Problem_Statement": "\na) Fill in the blanks above with the appropriate arguments for each malloc() statement. \nb) Next, write a function that takes a pointer to the array created by the makeArray() function, along with the number of employee records in that array (n) and frees all the dynamically allocated memory associated with that array. The function signature is as follows",
    "Problem_Code": "Employee *makeArray(char **firstNames, char **lastNames, int *IDs, int n;)\n{\n\tint i;\n\tEmployee *array = malloc();\n\n\tfor (i = 0; i < n; i++) \n\t{\n\t\tarray[i].first = malloc(sizeof(char) * (strlen(firsstNames[i]) + 1));\n\t\ttarray[i].last = malloc(sizeof(char) * (strlen(lastNames[i]) + 1));\n\n\t\tstrcpy(array[i].first, firstNames[i]);\n\t\tstrcpy(array[i].last, lastNames[i]);\n\t\tarray[i].ID = IDs[i];\n\t}\n\treturn array;\n}",
    "Solution": "Employee *makeArray(char **firstNames, char **lastNames, int *IDs, int n)\n{\n\t\tint i;\n\tEmployee *array = malloc(sizeof(Employee) * n) //1  point;\n\nfor (i = 0; i < n; i++) \n// The following blanks are worth 2 points EACH\n // Award 1 point each if close. Note that\n // (strlen (...) + 1) must be parenthesized in order\n // to earn full credit.\n\tarray[i].first = malloc(sizeof(char) * (strlen(firsstNames[i]) + 1));\n\tarray[i].last = malloc(sizeof(char) * (strlen(lastNames[i]) + 1));\n\n\tstrcpy(array[i].first, firstNames[i]);\n\tstrcpy(array[i].last, lastNames[i]);\narray[i].ID = IDs[i];\n}\nreturn array;\n}\n"
}
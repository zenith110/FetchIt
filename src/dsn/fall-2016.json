{
 "Problem_Name": " (10 pts) DSN (Dynamic Memory Management in C)",
 "Seen_On": "Fall 2016",
 "Problem_Statement": "Consider the following struct, which contains a string and its length in one nice, neat package:\ntypedef struct smart_string {\n char *word;\n int length;\n} smart_string;\nWrite a function that takes a string as its input, creates a new smart_string struct, and stores a new copy\nof that string in the word field of the struct and the length of that string in the length member of the\nstruct.\n The function should then return a pointer to that new smart_string struct.\n Use dynamic memory\nmanagement as necessary.\n The function signature is:",
 "Problem_Code": "smart_string *create_smart_string(char *str) {} Now write a function that takes a smart_string pointer (which might be NULL) as its only argument,\nfrees all dynamically allocated memory associated with that struct, and returns NULL when it\u2019s finished.\nsmart_string *erase_smart_string(smart_string *s) {}",
 "Solution": "smart_string *create_smart_string(char *str) {\n smart_string *s = malloc(sizeof(smart_string));\n s->length = strlen(str);\n s->word = malloc(sizeof(char) * (s->length + 1));\n strcpy(s->word, str);\n return s;\n}\nGrading (7 pts): 1 pt for smart_string declaration, 1 pt for first malloc, 1 pt for setting length\ncorrectly, 1 pt for sizeof(char) in second malloc, 1 pt for (s->length + 1) in second malloc, 1 pt for\nusing strcpy, and 1 pt for correct return statement. They can also use calloc(). Please deduct a\npoint for other large, obvious errors (such as using the . operator instead of the -> operator). smart_string *erase_smart_string(smart_string *s) {\n if (s != NULL)\n {\n free(s->word); // This is safe, even if word is NULL.\n free(s);\n }\n return NULL;\n}\nGrading (3 pts): 1 pt for checking s != NULL, 1 pt for free(s->word), and 1 pt for free(s)."
}
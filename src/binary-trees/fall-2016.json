{
 "Problem_Name": " (10 pts) DSN (Binary Trees)",
 "Seen_On": "Fall 2016",
 "Problem_Statement": "A binary search tree is considered \u201clopsided\u201d if the root\u2019s left subtree height and right subtree height\ndiffer by more than one (i.\ne.\n, the left subtree is more than one level deeper or shallower than the right\nsubtree).\n This is different from the definition of \u201cbalanced\u201d that comes up in relation to AVL trees,\nbecause the \u201clopsided\u201d property only applies to the root of the tree \u2013 not every single node in the tree.\n\nWrite a function, isLopsided(), that takes the root of a binary search tree and returns 1 if the tree is\nlopsided, and 0 otherwise.\n You may write helper functions as you see fit.\n The node struct and function\nsignature are as follows:",
 "Problem_Code": "typedef struct node {\n struct node *left, *right;\n int data;\n} node;\nint isLopsided(node *root)",
 "Solution": "int isLopsided(node *root)\n{\n int lHeight, rHeight, diff;\n if (root == NULL) return 0;\n lHeight = height(root->left);\n rHeight = height(root->right);\n diff = lHeight \u2013 rHeight;\n return (diff >= 2 || diff <= -2);\n}\nint max(int a, int b)\n{\n return (a > b) ? a : b;\n}\nint height(node *root)\n{\n if (root == NULL) return -1;\n return 1 + max(height(root->left), height(root->right));\n}\nGrading:\n 2 pts for checking root == NULL in isLopsided()\n 2 pts for realizing they need to write a separate height() function\n 3 pts for the rest of the logic in isLopsided, such as the diff check (award partial credit as you deem fit)\n 3 pts for the logic in height() (award partial credit as you deem fit)\n Note - for this particular question, if height returns 0 for null tree, that is fine since all that matters for\n correctness here is relative height."
}